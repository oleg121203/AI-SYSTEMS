# AI-SYSTEMS

## Суть програми AI-SYSTEMS

AI-SYSTEMS — це комплексна система, розроблена для автоматизації процесу розробки програмного забезпечення за допомогою взаємодії кількох спеціалізованих AI-агентів. Основна мета — взяти на вхід опис цілі проекту (target) і згенерувати відповідну структуру проекту, написати код, створити тести, написати документацію та забезпечити ітеративне покращення коду на основі результатів тестування.

## Архітектура системи

Система складається з наступних основних компонентів:

- **AI1 (Координатор)**: Планує та координує задачі, приймає рішення на основі результатів тестування.
- **AI2 (Виконавці)**: Генерують код (executor), тести (tester) та документацію (documenter).
- **AI3 (Дозор/Менеджер структури)**: Створює структуру проекту, моніторить систему, надає консультації.
- **MCP API**: Центральне API для взаємодії між компонентами, керує чергами завдань.
- **Веб-інтерфейс**: Візуалізація процесу розробки та управління системою.
- **GitHub Actions**: Автоматизоване тестування коду.

## Структура репозиторіїв

Система використовує два репозиторії:

1. **Основний репозиторій (AI-SYSTEMS)**: 
   - Містить код самої системи (AI-агенти, API, веб-інтерфейс)
   - URL: `https://github.com/oleg121203/AI-SYSTEMS.git`

2. **Репозиторій проекту (repo/)**: 
   - Вкладений репозиторій, де зберігається згенерований проект
   - AI3 автоматично створює файли та робить коміти
   - URL: `https://github.com/oleg121203/AI-SYSTEMS-REPO.git`

## Алгоритм роботи системи

1. **Ініціалізація (AI3):**
   * AI3 отримує ціль проекту (`target`) з конфігурації.
   * Генерує початкову JSON-структуру файлів та директорій проекту за допомогою LLM.
   * Створює ці файли та директорії у локальному репозиторії (repo).
   * Відправляє згенеровану структуру в MCP API.
   * Запускає фонові процеси моніторингу:
     * Простаюючих AI2-воркерів (executor, tester, documenter).
     * Помилок у лог-файлах системи.
     * Результатів тестів із GitHub Actions.

2. **Планування та координація (AI1):**
   * AI1 отримує структуру проекту від MCP API.
   * Будує високорівневу структуру основних завдань (наприклад, за компонентами: Backend, Frontend тощо).
   * **Отримує звіти від AI3:** AI1 використовує звіти від AI3 (про результати тестів, системні помилки, стан черг) для прийняття рішень щодо планування та коригування завдань.
   * Розбиває кожну основну задачу на мікрозадачі (зазвичай пофайлово: реалізація, тестування, документування).
   * **Отримує звіти від AI3:** AI1 може використовувати звіти AI3 для пріоритезації або модифікації мікрозадач.
   * Ініціалізує статуси для всіх мікрозадач.

3. **Розподіл та виконання завдань (AI1 -> MCP API -> AI2):**
   * AI1 починає керувати завданнями (`manage_tasks`):
     * Визначає, які завдання готові до виконання (наприклад, "executor" для нового файлу, "tester" після завершення "executor").
     * Створює конкретні підзадачі (з промптами, ID, роллю, іменем файлу, іноді з кодом) та відправляє їх у MCP API.
   * MCP API розміщує підзадачі у відповідні черги (executor, tester, documenter).
   * AI2-воркери (запущені окремо для кожної ролі) періодично запитують завдання зі своєї черги у MCP API (`/task/{role}`).
   * Отримавши завдання, AI2-воркер використовує відповідний LLM-провайдер для генерації контенту (коду, тестів, документації).
   * AI2 відправляє звіт (`/report`) з результатом (згенерований контент або статус помилки) назад у MCP API.

4. **Обробка звітів та оновлення статусу (MCP API):**
   * MCP API отримує звіти від AI2.
   * Якщо звіт містить код (`type: code`), він записується у відповідний файл у репозиторії (repo) та комітиться за допомогою Git.
   * Статус відповідної підзадачі оновлюється (наприклад, `code_received`, `tested`).
   * **Автоматичне створення наступних завдань:** MCP API автоматично створює завдання для тестувальника та документатора після отримання коду від executor. Така послідовність дозволяє паралельно працювати всім AI2-воркерам, підвищуючи загальну ефективність системи.
   * Оновлення статусу транслюється через WebSocket на веб-панель.

5. **Тестування (MCP API -> GitHub Actions -> AI3 -> MCP API -> AI1):**
   * Після того, як MCP API успішно записує та комітить код від AI2-executor в репозиторій проекту (`AI-SYSTEMS-REPO`), він **автоматично відправляє подію `repository_dispatch`** (типу `code-committed-in-repo`) до основного репозиторію `AI-SYSTEMS`.
   * Ця подія **тригерить запуск воркфлоу** `.github/workflows/python-tests.yml` в репозиторії `AI-SYSTEMS`.
   * Під час виконання воркфлоу завантажує код з обох репозиторіїв (`AI-SYSTEMS` в `main/`, `AI-SYSTEMS-REPO` в `repo/`).
   * Воркфлоу встановлює залежності для обох проектів.
   * Запускає `pytest` та лінтери для коду в `repo/` (модульні/інтеграційні тести).
   * **Запускає згенерований додаток** (наприклад, бекенд) у фоновому режимі.
   * **Запускає End-to-End (E2E) тести** (наприклад, за допомогою Playwright), які перевіряють роботу запущеного додатка.
   * Зупиняє фоновий процес додатка.
   * AI3 моніторить завершені запуски цього воркфлоу в репозиторії `AI-SYSTEMS` (`monitor_github_actions`).
   * AI3 аналізує результат (успіх/невдача тестів та лінтерів), визначає пов'язані файли та формує рекомендацію (`accept`/`rework`).
   * AI3 відправляє рекомендацію в MCP API (`/test_recommendation`).
   * MCP API оновлює статус тестових завдань та пересилає рекомендацію AI1.

6. **Прийняття рішень та доопрацювання (AI1):**
   * AI1 отримує результати тестів та рекомендацію AI3 (`handle_test_result`).
   * AI1 приймає остаточне рішення (`decide_on_test_results`): прийняти код (`accept`) чи відправити на доопрацювання (`rework`).
   * Якщо `accept`, статус відповідних завдань оновлюється на `accepted`.
   * Якщо `rework`, статус оновлюється на `needs_rework`, і AI1 створює нову підзадачу для AI2-executor з описом необхідних виправлень (на основі коментарів AI3 або логів помилок). Ця нова задача знову проходить через цикл виконання та тестування.
   * AI1 періодично перевіряє, чи всі завдання досягли фінального статусу (`accepted` або `skipped`).

7. **Моніторинг "Дозором" (AI3):**
   * Паралельно з усім процесом AI3:
     * Перевіряє стан всіх воркерів через ендпоінт `/worker_status` в MCP API. Якщо воркер простоює, запитує у MCP API нову задачу для нього (`/request_task_for_idle_worker`).
     * Якщо API для перевірки статусу недоступний, використовує резервний метод аналізу лог-файлів.
     * Збирає та аналізує статистику моніторингу.
     * **Якщо знаходить критичні помилки в логах, пов'язані з файлами в `repo/`, повідомляє про них AI1 через ендпоінт `/ai_collaboration`, надаючи контекст помилки.** AI1 потім вирішує, як реагувати (наприклад, створити завдання для AI2).
     * Моніторить результати тестів (як описано в п.5).

8. **Візуалізація (Dashboard):**
   * Веб-інтерфейс (`templates/index.html`, script.js, style.css) підключається до MCP API через WebSocket.
   * Відображає статуси AI-агентів, стан черг завдань, структуру файлів, логи, статистику та графіки прогресу в реальному часі.
   * Дозволяє користувачу керувати системою (старт/стоп агентів, скидання, редагування промптів).

## Розширені функції системи

### Управління середовищем розробки
* **Dev Container**: Система працює у контейнеризованому середовищі з усіма необхідними інструментами (Git, Docker, Python, Node.js, Go, Rust)
* **Автоматична настройка**: Скрипти для автоматичного налаштування середовища розробки

### Робота з LLM-провайдерами
* **Підтримка кількох LLM**: Можливість налаштування різних LLM для різних типів задач (код, тести, документація)
* **Ротація API-ключів**: Автоматичне перемикання між кількома API-ключами для уникнення лімітів
* **Кешування запитів**: Зменшення кількості запитів до LLM через збереження попередніх результатів

### Підтримка мультимовності
* **Багатомовні проекти**: Підтримка генерації проектів на різних мовах програмування
* **Локалізація веб-інтерфейсу**: Можливість вибору мови інтерфейсу

### Розширені можливості тестування
* **Аналіз покриття коду**: Інтеграція з інструментами аналізу покриття коду
* **Статичний аналіз**: Використання лінтерів та інших інструментів статичного аналізу
* **Інтеграційні тести**: Генерація та запуск інтеграційних тестів у воркфлоу.
* **End-to-End (E2E) Тести**: Воркфлоу автоматично запускає згенерований додаток та виконує E2E тести (наприклад, за допомогою Playwright) для перевірки його функціональності як єдиного цілого.

### Інструменти для розробників
* **CLI інтерфейс**: Управління системою через командний рядок 
* **Експорт/імпорт проектів**: Можливість експортувати та імпортувати проекти
* **Розширена аналітика**: Детальна статистика та метрики процесу розробки
* **Форматування кодових блоків**: Функція `format_code_blocks` автоматично виправляє форматування кодових блоків, додаючи пробіл між назвою мови і потрійними зворотними лапками. Це дозволяє уникнути проблем з парсингом коду в AI-системі.

#### Приклад використання:
```python
example_text = """python```print('Hello')```"""
formatted = format_code_blocks(example_text)
print(formatted)
```

## Налаштування та запуск

### Вимоги до системи
* Docker
* Git
* Python 3.10+
* Node.js 18+

### Швидкий старт
```bash
# Клонування репозиторію
git clone https://github.com/oleg121203/AI-SYSTEMS.git
cd AI-SYSTEMS

# Налаштування середовища
./setup.sh

# Запуск системи
./start.sh --target "Опис вашого проекту"
```

## Оцінка побудови системи

### Сильні сторони
* **Модульність:** Чіткий поділ відповідальності між AI-агентами (AI1 - координація, AI2 - виконання, AI3 - структура та моніторинг).
* **Автоматизація:** Повна автоматизація циклу розробки від структури до тестування та доопрацювання.
* **Зворотний зв'язок:** Замкнутий цикл тестування через GitHub Actions та аналіз результатів AI3 дозволяє системі самостійно покращувати код.
* **Моніторинг:** Роль "дозора" (AI3) додає системі стійкості, виявляючи проблеми (простої, помилки) та ініціюючи їх вирішення.
* **Консультації:** Механізм консультацій між AI1 та AI3 дозволяє покращувати планування завдань.
* **Централізоване API:** MCP API слугує єдиною точкою взаємодії, спрощуючи комунікацію.
* **Візуалізація:** Дашборд надає гарний огляд стану системи.
* **Автоматичне створення наступних завдань:** Система автоматично створює завдання для тестувальника та документатора одразу після отримання коду, забезпечуючи безперервний процес розробки.
* **Покращений моніторинг статусу воркерів:** AI3 використовує спеціальний ендпоінт `/worker_status` для ефективного виявлення простоюючих воркерів.

### Області для покращення
* **Складність:** Система досить складна через велику кількість взаємодіючих компонентів. Відладка та підтримка можуть бути непростими.
* **Надійність LLM:** Якість кінцевого продукту сильно залежить від якості генерації коду/тестів/документації базовими LLM. Потрібне ретельне налаштування промптів.
* **Обробка помилок:** Система має бути стійкою до помилок на кожному етапі (помилки API, помилки LLM, помилки Git, помилки GitHub Actions). Поточна обробка може потребувати розширення.
* **Ефективність доопрацювання:** Механізм доопрацювання (коли AI1 створює нову задачу на виправлення) має бути ефективним, щоб не зациклюватися на одних і тих самих помилках. Можливо, потрібні складніші стратегії виправлення.
* **Управління станом:** Синхронізація стану між усіма компонентами (особливо статуси завдань) є критично важливою і може бути складною.
* **Масштабованість:** Зі збільшенням розміру проекту може зрости навантаження на API та LLM-провайдерів.
* **GitHub Actions:** Поточний воркфлоу може бути не оптимальним (наприклад, запускати тести лише для файлів, пов'язаних зі зміненим кодом, а не лише змінених тестів).

## Плани розвитку

### Короткострокові
* Покращення системи обробки помилок
* Розширення набору підтримуваних мов програмування
* Оптимізація процесу тестування

### Середньострокові
* Інтеграція з іншими CI/CD системами (крім GitHub Actions)
* Впровадження механізмів машинного навчання для покращення якості генерації
* Додавання підтримки мобільної розробки

### Довгострокові
* Розробка плагінів для популярних IDE
* Створення маркетплейсу шаблонів проектів
* Підтримка розподіленої розробки кількома командами

## Внесок у проект

Ми раді будь-якому внеску в проект! Додаткову інформацію можна знайти в файлі CONTRIBUTING.md.

## Ліцензія

Проект розповсюджується під ліцензією MIT. Детальну інформацію можна знайти в файлі LICENSE.

## Висновок

Система AI-SYSTEMS має продуману архітектуру з чітким розподілом ролей та автоматизованим циклом розробки з тестуванням і доопрацюванням. Включення AI3 як "дозора" та механізму консультацій є сильними сторонами. Основні виклики полягають у надійності LLM, комплексній обробці помилок та ефективному управлінні станом у такій складній системі. Загалом, це амбітний та добре структурований підхід до автоматизації створення ПЗ за допомогою AI.